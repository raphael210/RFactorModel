% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fct02_portBuildingFuncs.R
\name{PortfolioBacktest}
\alias{PortfolioBacktest}
\alias{getPort}
\alias{addwgt2port}
\alias{port.substitute}
\alias{getPort_throughout}
\alias{port.backtest}
\alias{getPB}
\title{portfolio building and backtesting}
\usage{
getPort(TSF, topN = NA, topQ = NA, factorNA = "median",
  pick.sectorNe = FALSE, sectorAttr = defaultSectorAttr(), force_in = 0,
  buffer_keep = 0, buffer_rate = 0, init_port = NULL, backtestPar,
  dir = c("long", "short"))

addwgt2port(port, wgtType = c("eq", "fv", "fvsqrt", "custom", "ffv",
  "ffvsqrt"), wgt.sectorNe = FALSE, wgtbmk = "EI000300",
  sectorAttr = defaultSectorAttr(), backtestPar, tolerance = 0.2)

port.substitute(port, TSF, wgt.max = NA, sectorAttr = defaultSectorAttr(),
  backtestPar, dir = c("long", "short"))

getPort_throughout(TSF, topN = NA, topQ = NA, factorNA = "median",
  pick.sectorNe = FALSE, force_in = 0, buffer_keep = 0, buffer_rate = 0,
  init_port = NULL, wgtType = "eq", wgt.sectorNe = FALSE,
  wgtbmk = "EI000300", wgt.max = NA, sectorAttr = defaultSectorAttr(),
  backtestPar, dir = c("long", "short"))

port.backtest(port, holdingEndT = Sys.Date(), fee.buy = 0, fee.sell = 0,
  backtestPar, dir = c("long", "short"), rtn_get = c("loop", "whole",
  "simple"))

getPB(TSF, topN = NA, topQ = NA, factorNA = "median",
  pick.sectorNe = FALSE, force_in = 0, buffer_keep = 0, buffer_rate = 0,
  init_port = NULL, wgtType = "eq", wgt.sectorNe = FALSE,
  wgtbmk = "EI000300", wgt.max = NA, holdingEndT = Sys.Date(),
  fee.buy = 0, fee.sell = fee.buy, sectorAttr = defaultSectorAttr(),
  backtestPar, dir = c("long", "short"))
}
\arguments{
\item{TSF}{a \bold{TSF} object or a \bold{TSFR} object}

\item{topN}{an integer vector with 2 or 1 elements, giving the rank range of the assets to be selected into the portfolio. If containing only 1 element, the the top rank of 1 will be added automatically.}

\item{topQ}{a numeric vector with 2 or 1 elements, giving the percentage range of the assets to be selected into the portfolio.  If containing only 1 element, the top percentage of 0 will be added automatically.}

\item{force_in}{a numeric between 0 and 1. eg. 0.1 means that stock with rank less than topN*10\%  or pct less than topQ*10\% will be incorporated coercively.}

\item{buffer_keep}{a numeric greater than 0. eg. 0.1 means that stock with rank less than topN*110\% (\code{topN*(1+buffer_keep)}) or pct less than topQ*110\% will be kept coercively.}

\item{init_port}{a charactor vector of stockIDs.}

\item{backtestPar}{a \bold{backtestPar} object. If param backtestPar is not missing,then the other params will be extracted from backtestPar.It is usefull when the backtestPar has been initialized.}

\item{dir}{a character string "long" or "short". In \code{getPort}, if "short",select from top to bottom, and vice versa.}

\item{wgtType}{a character string, giving the weighting type of portfolio,which could be "eq"(equal),"fv"(floatValue),"fvsqrt"(sqrt of floatValue) or "custom".}

\item{wgt.sectorNe}{a logic. If true, the wgt will be neutralized by sector.}

\item{tolerance}{a numeric, only used when \code{wgt.sectorNe} is true. Giving the tolerance of absent sectors weights in the portfolio.}

\item{wgt.max}{a numeric or NA, giving the maximum of weight which could be set on a single stock. If NA(the default value), with no limit, return \code{port} itself without doing anything.}

\item{holdingEndT}{a Date object, giving the ending date of the holding portfolio}

\item{fee.buy}{giving the buying fee of each assets. See \code{\link[QUtility]{Return.backtesting}} for detail}

\item{fee.sell}{}

\item{rtn_get}{a character string of "loop","whole","simple". "loop" and "whole" get the dailyrtn, where as "simple" get the periodrtn.}

\item{dir}{a character string of "long" or "short". In \code{port.substitute}, indicating the port direction. If "long",the port will be look as a long portfolio, and will import stocks from the top of the TSF; vise versa.}

\item{dir}{a character string of "long" or "short". In \code{port.backtest}, if "long", the port will be look as asset, the fee will be cut from the asset; if "short", the port will be look as liability, the fee will be added to the liability.}
}
\value{
\code{getPort} return a \bold{Port}('portfolio') objects,which are of dataframe class containing at least 2 cols("date","stockID")

\code{addwgt2port} return a \bold{Port} object which are of dataframe class containing at least 3 cols("date","stockID","wgt").

\code{port.substitute} return a \bold{Port} object

\code{getPort_throughout} return a \bold{Port} object, which contain the col of 'wgt'.

\code{port.backtest} return a \bold{PB}("PortfolioBacktest") object, a xts series of portfolio return, with the attr of 'turnover'(a xts series) and 'fee'(a vector).

\code{getPB} return a \bold{PB}("PortfolioBacktest") object.
}
\description{
portfolio building and backtesting
}
\details{
\code{getPort} get the \bold{Port}('portfolio') objects, subsetting from the \bold{TSF} object.

\code{addwgt2port} add the weights to the \bold{Port} object.

\code{port.substitute} redistribute the extra weight to other stocks to reduce the risk of concentration,when too much weight on single stock. 

TSF is used when the stocks in \code{port} is not enough to share the extra weights. In that case, stock in TSF, which is in the same sector, will be imported into the port to share the extra weights.

\code{getPort_throughout}, which is a wrapped function of \code{getPort}, \code{addwgt2Port}, \code{port.substitute}, get \bold{Port} object from \bold{TSF}, with further treatment.

\code{port.backtest} backtest the \bold{Port} object. Get a \bold{PB}("PortfolioBacktest") object.

\code{getPB}, which is a wrapped function of \code{getPort}, \code{addwgt2Port}, \code{port.substitute}, \code{port.backtest}, get \bold{PB} object from \bold{TSF} directly.
}
\note{
Note that \code{topN} and \code{topQ} should at least have one and only have one.

Note that if use bufferring, the length of topN (or topQ) should be 1.

Note that if pick.sectorNe is TRUE, the param topN and topQ will act \bold{in the sector}. That is , for example, topN=10 means picking 10 stocks in every sectors. For that reason, if pick.sectorNe is true, topQ is a better choise than topN.

If the \code{port} and \code{TSF} originally contain the column "sector", it will be droped before the new sector imported according to the specified auguments.
}
\examples{
modelPar <- modelPar.default()
TSFR <- Model.TSFR(modelPar)
# -- good ports
Lport1 <- getPort(TSFR,20)
Lport2 <- getPort(TSFR,c(1,20)) # the same as Lport1
Lport3 <- getPort(TSFR,,0.2)
Lport4 <- getPort(TSFR,,c(0.1,0.2))
# -- bad ports
Sport1 <- getPort(TSFR,20,dir="short")
Sport2 <- getPort(TSFR,c(10,20),dir="short")
Sport3 <- getPort(TSFR,,0.2,dir="short")
Sport4 <- getPort(TSFR,,c(0.1,0.2),dir="short")
# -- N groups of ports
N <- 5
tmp <- seq(0,1,by=1/N)
groups <- cbind(tmp[-(N+1)],tmp[-1])
port.list <- apply(groups,1,function(x)getPort(TSFR,,x))
# -- with buffer_in_keep
ts <- getTS(as.Date(c("2016-03-31","2016-04-29")),indexID = "EI000016")
tsf <- getTSF(ts,"gf_lcfs",list("F000008"),factorDir = -1) 
pt <- getPort(tsf,20,force_in = 0.5,buffer_keep = 0.5)
factorList <- buildFactorList(factorFun = "gf.mkt_cap", factorStd = "norm", factorNA = "na")
pt2 <- getPort(tsf,20,force_in = 0.5,buffer_keep = 0.5,pick.sectorNe = T,sectorAttr = list(list(factorList),list(2)))
# -- with buffer_rate
pt3 <- getPort(tsf,20,buffer_rate =  0.5,pick.sectorNe =F)
pt4 <- getPort(tsf,topQ = 0.4,buffer_rate =  0.5,pick.sectorNe =F)
pt5 <- getPort(tsf,20,buffer_rate =  0.5,pick.sectorNe =T,sectorAttr = list(list(factorList1),list(2)))
pt6 <- getPort(tsf,topQ = 0.4,buffer_rate =  0.5,pick.sectorNe =T,sectorAttr = list(list(factorList1),list(2)))
# -- add wgt to port
port <- getPort(TSF,20)
port <- addwgt2port(port,"fv")
# -- reduce the risk of concentration
port <- port.substitute(port,TSF,wgt.max=0.08)
# -- get Port object from TSF throughout
Port_throut <- getPort_throughout(TSF, topN=20, wgt.max=0.8, dir="long")
# -- backtest the Port object
PB <- port.backtest(port)
turnover <- attr(PB,"turnover")
fee <- attr(PB,"fee")
# -- get PB object from TSF directly
PB <- getPB(TSF, topN=20, dir="long")
}
\seealso{
\code{\link[QUtility]{Return.backtesting}}
}
\author{
Ruifei.Yin
}
